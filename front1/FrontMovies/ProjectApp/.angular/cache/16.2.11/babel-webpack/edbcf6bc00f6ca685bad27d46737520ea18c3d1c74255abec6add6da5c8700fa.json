{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/USER/Desktop/Front-end/ProjectApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { BehaviorSubject } from 'rxjs';\n\n/** Subject used to dispatch and listen for changes to the auto change detection status . */\nconst autoChangeDetectionSubject = new BehaviorSubject({\n  isDisabled: false\n});\n/** The current subscription to `autoChangeDetectionSubject`. */\nlet autoChangeDetectionSubscription;\n/**\n * The default handler for auto change detection status changes. This handler will be used if the\n * specific environment does not install its own.\n * @param status The new auto change detection status.\n */\nfunction defaultAutoChangeDetectionHandler(status) {\n  status.onDetectChangesNow?.();\n}\n/**\n * Allows a test `HarnessEnvironment` to install its own handler for auto change detection status\n * changes.\n * @param handler The handler for the auto change detection status.\n */\nfunction handleAutoChangeDetectionStatus(handler) {\n  stopHandlingAutoChangeDetectionStatus();\n  autoChangeDetectionSubscription = autoChangeDetectionSubject.subscribe(handler);\n}\n/** Allows a `HarnessEnvironment` to stop handling auto change detection status changes. */\nfunction stopHandlingAutoChangeDetectionStatus() {\n  autoChangeDetectionSubscription?.unsubscribe();\n  autoChangeDetectionSubscription = null;\n}\n/**\n * Batches together triggering of change detection over the duration of the given function.\n * @param fn The function to call with batched change detection.\n * @param triggerBeforeAndAfter Optionally trigger change detection once before and after the batch\n *   operation. If false, change detection will not be triggered.\n * @return The result of the given function.\n */\nfunction batchChangeDetection(_x, _x2) {\n  return _batchChangeDetection.apply(this, arguments);\n}\n/**\n * Disables the harness system's auto change detection for the duration of the given function.\n * @param fn The function to disable auto change detection for.\n * @return The result of the given function.\n */\nfunction _batchChangeDetection() {\n  _batchChangeDetection = _asyncToGenerator(function* (fn, triggerBeforeAndAfter) {\n    // If change detection batching is already in progress, just run the function.\n    if (autoChangeDetectionSubject.getValue().isDisabled) {\n      return yield fn();\n    }\n    // If nothing is handling change detection batching, install the default handler.\n    if (!autoChangeDetectionSubscription) {\n      handleAutoChangeDetectionStatus(defaultAutoChangeDetectionHandler);\n    }\n    if (triggerBeforeAndAfter) {\n      yield new Promise(resolve => autoChangeDetectionSubject.next({\n        isDisabled: true,\n        onDetectChangesNow: resolve\n      }));\n      // The function passed in may throw (e.g. if the user wants to make an expectation of an error\n      // being thrown. If this happens, we need to make sure we still re-enable change detection, so\n      // we wrap it in a `finally` block.\n      try {\n        return yield fn();\n      } finally {\n        yield new Promise(resolve => autoChangeDetectionSubject.next({\n          isDisabled: false,\n          onDetectChangesNow: resolve\n        }));\n      }\n    } else {\n      autoChangeDetectionSubject.next({\n        isDisabled: true\n      });\n      // The function passed in may throw (e.g. if the user wants to make an expectation of an error\n      // being thrown. If this happens, we need to make sure we still re-enable change detection, so\n      // we wrap it in a `finally` block.\n      try {\n        return yield fn();\n      } finally {\n        autoChangeDetectionSubject.next({\n          isDisabled: false\n        });\n      }\n    }\n  });\n  return _batchChangeDetection.apply(this, arguments);\n}\nfunction manualChangeDetection(_x3) {\n  return _manualChangeDetection.apply(this, arguments);\n}\n/**\n * Resolves the given list of async values in parallel (i.e. via Promise.all) while batching change\n * detection over the entire operation such that change detection occurs exactly once before\n * resolving the values and once after.\n * @param values A getter for the async values to resolve in parallel with batched change detection.\n * @return The resolved values.\n */\nfunction _manualChangeDetection() {\n  _manualChangeDetection = _asyncToGenerator(function* (fn) {\n    return batchChangeDetection(fn, false);\n  });\n  return _manualChangeDetection.apply(this, arguments);\n}\nfunction parallel(_x4) {\n  return _parallel.apply(this, arguments);\n}\n/**\n * Base class for component harnesses that all component harness authors should extend. This base\n * component harness provides the basic ability to locate element and sub-component harness. It\n * should be inherited when defining user's own harness.\n */\nfunction _parallel() {\n  _parallel = _asyncToGenerator(function* (values) {\n    return batchChangeDetection(() => Promise.all(values()), true);\n  });\n  return _parallel.apply(this, arguments);\n}\nclass ComponentHarness {\n  constructor(locatorFactory) {\n    this.locatorFactory = locatorFactory;\n  }\n  /** Gets a `Promise` for the `TestElement` representing the host element of the component. */\n  host() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return _this.locatorFactory.rootElement;\n    })();\n  }\n  /**\n   * Gets a `LocatorFactory` for the document root element. This factory can be used to create\n   * locators for elements that a component creates outside of its own root element. (e.g. by\n   * appending to document.body).\n   */\n  documentRootLocatorFactory() {\n    return this.locatorFactory.documentRootLocatorFactory();\n  }\n  /**\n   * Creates an asynchronous locator function that can be used to find a `ComponentHarness` instance\n   * or element under the host element of this `ComponentHarness`.\n   * @param queries A list of queries specifying which harnesses and elements to search for:\n   *   - A `string` searches for elements matching the CSS selector specified by the string.\n   *   - A `ComponentHarness` constructor searches for `ComponentHarness` instances matching the\n   *     given class.\n   *   - A `HarnessPredicate` searches for `ComponentHarness` instances matching the given\n   *     predicate.\n   * @return An asynchronous locator function that searches for and returns a `Promise` for the\n   *   first element or harness matching the given search criteria. Matches are ordered first by\n   *   order in the DOM, and second by order in the queries list. If no matches are found, the\n   *   `Promise` rejects. The type that the `Promise` resolves to is a union of all result types for\n   *   each query.\n   *\n   * e.g. Given the following DOM: `<div id=\"d1\" /><div id=\"d2\" />`, and assuming\n   * `DivHarness.hostSelector === 'div'`:\n   * - `await ch.locatorFor(DivHarness, 'div')()` gets a `DivHarness` instance for `#d1`\n   * - `await ch.locatorFor('div', DivHarness)()` gets a `TestElement` instance for `#d1`\n   * - `await ch.locatorFor('span')()` throws because the `Promise` rejects.\n   */\n  locatorFor(...queries) {\n    return this.locatorFactory.locatorFor(...queries);\n  }\n  /**\n   * Creates an asynchronous locator function that can be used to find a `ComponentHarness` instance\n   * or element under the host element of this `ComponentHarness`.\n   * @param queries A list of queries specifying which harnesses and elements to search for:\n   *   - A `string` searches for elements matching the CSS selector specified by the string.\n   *   - A `ComponentHarness` constructor searches for `ComponentHarness` instances matching the\n   *     given class.\n   *   - A `HarnessPredicate` searches for `ComponentHarness` instances matching the given\n   *     predicate.\n   * @return An asynchronous locator function that searches for and returns a `Promise` for the\n   *   first element or harness matching the given search criteria. Matches are ordered first by\n   *   order in the DOM, and second by order in the queries list. If no matches are found, the\n   *   `Promise` is resolved with `null`. The type that the `Promise` resolves to is a union of all\n   *   result types for each query or null.\n   *\n   * e.g. Given the following DOM: `<div id=\"d1\" /><div id=\"d2\" />`, and assuming\n   * `DivHarness.hostSelector === 'div'`:\n   * - `await ch.locatorForOptional(DivHarness, 'div')()` gets a `DivHarness` instance for `#d1`\n   * - `await ch.locatorForOptional('div', DivHarness)()` gets a `TestElement` instance for `#d1`\n   * - `await ch.locatorForOptional('span')()` gets `null`.\n   */\n  locatorForOptional(...queries) {\n    return this.locatorFactory.locatorForOptional(...queries);\n  }\n  /**\n   * Creates an asynchronous locator function that can be used to find `ComponentHarness` instances\n   * or elements under the host element of this `ComponentHarness`.\n   * @param queries A list of queries specifying which harnesses and elements to search for:\n   *   - A `string` searches for elements matching the CSS selector specified by the string.\n   *   - A `ComponentHarness` constructor searches for `ComponentHarness` instances matching the\n   *     given class.\n   *   - A `HarnessPredicate` searches for `ComponentHarness` instances matching the given\n   *     predicate.\n   * @return An asynchronous locator function that searches for and returns a `Promise` for all\n   *   elements and harnesses matching the given search criteria. Matches are ordered first by\n   *   order in the DOM, and second by order in the queries list. If an element matches more than\n   *   one `ComponentHarness` class, the locator gets an instance of each for the same element. If\n   *   an element matches multiple `string` selectors, only one `TestElement` instance is returned\n   *   for that element. The type that the `Promise` resolves to is an array where each element is\n   *   the union of all result types for each query.\n   *\n   * e.g. Given the following DOM: `<div id=\"d1\" /><div id=\"d2\" />`, and assuming\n   * `DivHarness.hostSelector === 'div'` and `IdIsD1Harness.hostSelector === '#d1'`:\n   * - `await ch.locatorForAll(DivHarness, 'div')()` gets `[\n   *     DivHarness, // for #d1\n   *     TestElement, // for #d1\n   *     DivHarness, // for #d2\n   *     TestElement // for #d2\n   *   ]`\n   * - `await ch.locatorForAll('div', '#d1')()` gets `[\n   *     TestElement, // for #d1\n   *     TestElement // for #d2\n   *   ]`\n   * - `await ch.locatorForAll(DivHarness, IdIsD1Harness)()` gets `[\n   *     DivHarness, // for #d1\n   *     IdIsD1Harness, // for #d1\n   *     DivHarness // for #d2\n   *   ]`\n   * - `await ch.locatorForAll('span')()` gets `[]`.\n   */\n  locatorForAll(...queries) {\n    return this.locatorFactory.locatorForAll(...queries);\n  }\n  /**\n   * Flushes change detection and async tasks in the Angular zone.\n   * In most cases it should not be necessary to call this manually. However, there may be some edge\n   * cases where it is needed to fully flush animation events.\n   */\n  forceStabilize() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      return _this2.locatorFactory.forceStabilize();\n    })();\n  }\n  /**\n   * Waits for all scheduled or running async tasks to complete. This allows harness\n   * authors to wait for async tasks outside of the Angular zone.\n   */\n  waitForTasksOutsideAngular() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      return _this3.locatorFactory.waitForTasksOutsideAngular();\n    })();\n  }\n}\n/**\n * Base class for component harnesses that authors should extend if they anticipate that consumers\n * of the harness may want to access other harnesses within the `<ng-content>` of the component.\n */\nclass ContentContainerComponentHarness extends ComponentHarness {\n  getChildLoader(selector) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      return (yield _this4.getRootHarnessLoader()).getChildLoader(selector);\n    })();\n  }\n  getAllChildLoaders(selector) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      return (yield _this5.getRootHarnessLoader()).getAllChildLoaders(selector);\n    })();\n  }\n  getHarness(query) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      return (yield _this6.getRootHarnessLoader()).getHarness(query);\n    })();\n  }\n  getHarnessOrNull(query) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      return (yield _this7.getRootHarnessLoader()).getHarnessOrNull(query);\n    })();\n  }\n  getAllHarnesses(query) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      return (yield _this8.getRootHarnessLoader()).getAllHarnesses(query);\n    })();\n  }\n  hasHarness(query) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      return (yield _this9.getRootHarnessLoader()).hasHarness(query);\n    })();\n  }\n  /**\n   * Gets the root harness loader from which to start\n   * searching for content contained by this harness.\n   */\n  getRootHarnessLoader() {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      return _this10.locatorFactory.rootHarnessLoader();\n    })();\n  }\n}\n/**\n * A class used to associate a ComponentHarness class with predicates functions that can be used to\n * filter instances of the class.\n */\nclass HarnessPredicate {\n  constructor(harnessType, options) {\n    this.harnessType = harnessType;\n    this._predicates = [];\n    this._descriptions = [];\n    this._addBaseOptions(options);\n  }\n  /**\n   * Checks if the specified nullable string value matches the given pattern.\n   * @param value The nullable string value to check, or a Promise resolving to the\n   *   nullable string value.\n   * @param pattern The pattern the value is expected to match. If `pattern` is a string,\n   *   `value` is expected to match exactly. If `pattern` is a regex, a partial match is\n   *   allowed. If `pattern` is `null`, the value is expected to be `null`.\n   * @return Whether the value matches the pattern.\n   */\n  static stringMatches(value, pattern) {\n    return _asyncToGenerator(function* () {\n      value = yield value;\n      if (pattern === null) {\n        return value === null;\n      } else if (value === null) {\n        return false;\n      }\n      return typeof pattern === 'string' ? value === pattern : pattern.test(value);\n    })();\n  }\n  /**\n   * Adds a predicate function to be run against candidate harnesses.\n   * @param description A description of this predicate that may be used in error messages.\n   * @param predicate An async predicate function.\n   * @return this (for method chaining).\n   */\n  add(description, predicate) {\n    this._descriptions.push(description);\n    this._predicates.push(predicate);\n    return this;\n  }\n  /**\n   * Adds a predicate function that depends on an option value to be run against candidate\n   * harnesses. If the option value is undefined, the predicate will be ignored.\n   * @param name The name of the option (may be used in error messages).\n   * @param option The option value.\n   * @param predicate The predicate function to run if the option value is not undefined.\n   * @return this (for method chaining).\n   */\n  addOption(name, option, predicate) {\n    if (option !== undefined) {\n      this.add(`${name} = ${_valueAsString(option)}`, item => predicate(item, option));\n    }\n    return this;\n  }\n  /**\n   * Filters a list of harnesses on this predicate.\n   * @param harnesses The list of harnesses to filter.\n   * @return A list of harnesses that satisfy this predicate.\n   */\n  filter(harnesses) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      if (harnesses.length === 0) {\n        return [];\n      }\n      const results = yield parallel(() => harnesses.map(h => _this11.evaluate(h)));\n      return harnesses.filter((_, i) => results[i]);\n    })();\n  }\n  /**\n   * Evaluates whether the given harness satisfies this predicate.\n   * @param harness The harness to check\n   * @return A promise that resolves to true if the harness satisfies this predicate,\n   *   and resolves to false otherwise.\n   */\n  evaluate(harness) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const results = yield parallel(() => _this12._predicates.map(p => p(harness)));\n      return results.reduce((combined, current) => combined && current, true);\n    })();\n  }\n  /** Gets a description of this predicate for use in error messages. */\n  getDescription() {\n    return this._descriptions.join(', ');\n  }\n  /** Gets the selector used to find candidate elements. */\n  getSelector() {\n    // We don't have to go through the extra trouble if there are no ancestors.\n    if (!this._ancestor) {\n      return (this.harnessType.hostSelector || '').trim();\n    }\n    const [ancestors, ancestorPlaceholders] = _splitAndEscapeSelector(this._ancestor);\n    const [selectors, selectorPlaceholders] = _splitAndEscapeSelector(this.harnessType.hostSelector || '');\n    const result = [];\n    // We have to add the ancestor to each part of the host compound selector, otherwise we can get\n    // incorrect results. E.g. `.ancestor .a, .ancestor .b` vs `.ancestor .a, .b`.\n    ancestors.forEach(escapedAncestor => {\n      const ancestor = _restoreSelector(escapedAncestor, ancestorPlaceholders);\n      return selectors.forEach(escapedSelector => result.push(`${ancestor} ${_restoreSelector(escapedSelector, selectorPlaceholders)}`));\n    });\n    return result.join(', ');\n  }\n  /** Adds base options common to all harness types. */\n  _addBaseOptions(options) {\n    this._ancestor = options.ancestor || '';\n    if (this._ancestor) {\n      this._descriptions.push(`has ancestor matching selector \"${this._ancestor}\"`);\n    }\n    const selector = options.selector;\n    if (selector !== undefined) {\n      this.add(`host matches selector \"${selector}\"`, /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (item) {\n          return (yield item.host()).matchesSelector(selector);\n        });\n        return function (_x5) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    }\n  }\n}\n/** Represent a value as a string for the purpose of logging. */\nfunction _valueAsString(value) {\n  if (value === undefined) {\n    return 'undefined';\n  }\n  try {\n    // `JSON.stringify` doesn't handle RegExp properly, so we need a custom replacer.\n    // Use a character that is unlikely to appear in real strings to denote the start and end of\n    // the regex. This allows us to strip out the extra quotes around the value added by\n    // `JSON.stringify`. Also do custom escaping on `\"` characters to prevent `JSON.stringify`\n    // from escaping them as if they were part of a string.\n    const stringifiedValue = JSON.stringify(value, (_, v) => v instanceof RegExp ? `◬MAT_RE_ESCAPE◬${v.toString().replace(/\"/g, '◬MAT_RE_ESCAPE◬')}◬MAT_RE_ESCAPE◬` : v);\n    // Strip out the extra quotes around regexes and put back the manually escaped `\"` characters.\n    return stringifiedValue.replace(/\"◬MAT_RE_ESCAPE◬|◬MAT_RE_ESCAPE◬\"/g, '').replace(/◬MAT_RE_ESCAPE◬/g, '\"');\n  } catch {\n    // `JSON.stringify` will throw if the object is cyclical,\n    // in this case the best we can do is report the value as `{...}`.\n    return '{...}';\n  }\n}\n/**\n * Splits up a compound selector into its parts and escapes any quoted content. The quoted content\n * has to be escaped, because it can contain commas which will throw throw us off when trying to\n * split it.\n * @param selector Selector to be split.\n * @returns The escaped string where any quoted content is replaced with a placeholder. E.g.\n * `[foo=\"bar\"]` turns into `[foo=__cdkPlaceholder-0__]`. Use `_restoreSelector` to restore\n * the placeholders.\n */\nfunction _splitAndEscapeSelector(selector) {\n  const placeholders = [];\n  // Note that the regex doesn't account for nested quotes so something like `\"ab'cd'e\"` will be\n  // considered as two blocks. It's a bit of an edge case, but if we find that it's a problem,\n  // we can make it a bit smarter using a loop. Use this for now since it's more readable and\n  // compact. More complete implementation:\n  // https://github.com/angular/angular/blob/bd34bc9e89f18a/packages/compiler/src/shadow_css.ts#L655\n  const result = selector.replace(/([\"'][^[\"']*[\"'])/g, (_, keep) => {\n    const replaceBy = `__cdkPlaceholder-${placeholders.length}__`;\n    placeholders.push(keep);\n    return replaceBy;\n  });\n  return [result.split(',').map(part => part.trim()), placeholders];\n}\n/** Restores a selector whose content was escaped in `_splitAndEscapeSelector`. */\nfunction _restoreSelector(selector, placeholders) {\n  return selector.replace(/__cdkPlaceholder-(\\d+)__/g, (_, index) => placeholders[+index]);\n}\n\n/**\n * Base harness environment class that can be extended to allow `ComponentHarness`es to be used in\n * different test environments (e.g. testbed, protractor, etc.). This class implements the\n * functionality of both a `HarnessLoader` and `LocatorFactory`. This class is generic on the raw\n * element type, `E`, used by the particular test environment.\n */\nclass HarnessEnvironment {\n  // Implemented as part of the `LocatorFactory` interface.\n  get rootElement() {\n    this._rootElement = this._rootElement || this.createTestElement(this.rawRootElement);\n    return this._rootElement;\n  }\n  set rootElement(element) {\n    this._rootElement = element;\n  }\n  constructor(rawRootElement) {\n    this.rawRootElement = rawRootElement;\n  }\n  // Implemented as part of the `LocatorFactory` interface.\n  documentRootLocatorFactory() {\n    return this.createEnvironment(this.getDocumentRoot());\n  }\n  // Implemented as part of the `LocatorFactory` interface.\n  locatorFor(...queries) {\n    return () => _assertResultFound(this._getAllHarnessesAndTestElements(queries), _getDescriptionForLocatorForQueries(queries));\n  }\n  // Implemented as part of the `LocatorFactory` interface.\n  locatorForOptional(...queries) {\n    var _this13 = this;\n    return /*#__PURE__*/_asyncToGenerator(function* () {\n      return (yield _this13._getAllHarnessesAndTestElements(queries))[0] || null;\n    });\n  }\n  // Implemented as part of the `LocatorFactory` interface.\n  locatorForAll(...queries) {\n    return () => this._getAllHarnessesAndTestElements(queries);\n  }\n  // Implemented as part of the `LocatorFactory` interface.\n  rootHarnessLoader() {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      return _this14;\n    })();\n  }\n  // Implemented as part of the `LocatorFactory` interface.\n  harnessLoaderFor(selector) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      return _this15.createEnvironment(yield _assertResultFound(_this15.getAllRawElements(selector), [_getDescriptionForHarnessLoaderQuery(selector)]));\n    })();\n  }\n  // Implemented as part of the `LocatorFactory` interface.\n  harnessLoaderForOptional(selector) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      const elements = yield _this16.getAllRawElements(selector);\n      return elements[0] ? _this16.createEnvironment(elements[0]) : null;\n    })();\n  }\n  // Implemented as part of the `LocatorFactory` interface.\n  harnessLoaderForAll(selector) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      const elements = yield _this17.getAllRawElements(selector);\n      return elements.map(element => _this17.createEnvironment(element));\n    })();\n  }\n  // Implemented as part of the `HarnessLoader` interface.\n  getHarness(query) {\n    return this.locatorFor(query)();\n  }\n  // Implemented as part of the `HarnessLoader` interface.\n  getHarnessOrNull(query) {\n    return this.locatorForOptional(query)();\n  }\n  // Implemented as part of the `HarnessLoader` interface.\n  getAllHarnesses(query) {\n    return this.locatorForAll(query)();\n  }\n  // Implemented as part of the `HarnessLoader` interface.\n  hasHarness(query) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      return (yield _this18.locatorForOptional(query)()) !== null;\n    })();\n  }\n  // Implemented as part of the `HarnessLoader` interface.\n  getChildLoader(selector) {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      return _this19.createEnvironment(yield _assertResultFound(_this19.getAllRawElements(selector), [_getDescriptionForHarnessLoaderQuery(selector)]));\n    })();\n  }\n  // Implemented as part of the `HarnessLoader` interface.\n  getAllChildLoaders(selector) {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      return (yield _this20.getAllRawElements(selector)).map(e => _this20.createEnvironment(e));\n    })();\n  }\n  /** Creates a `ComponentHarness` for the given harness type with the given raw host element. */\n  createComponentHarness(harnessType, element) {\n    return new harnessType(this.createEnvironment(element));\n  }\n  /**\n   * Matches the given raw elements with the given list of element and harness queries to produce a\n   * list of matched harnesses and test elements.\n   */\n  _getAllHarnessesAndTestElements(queries) {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      if (!queries.length) {\n        throw Error('CDK Component harness query must contain at least one element.');\n      }\n      const {\n        allQueries,\n        harnessQueries,\n        elementQueries,\n        harnessTypes\n      } = _parseQueries(queries);\n      // Combine all of the queries into one large comma-delimited selector and use it to get all raw\n      // elements matching any of the individual queries.\n      const rawElements = yield _this21.getAllRawElements([...elementQueries, ...harnessQueries.map(predicate => predicate.getSelector())].join(','));\n      // If every query is searching for the same harness subclass, we know every result corresponds\n      // to an instance of that subclass. Likewise, if every query is for a `TestElement`, we know\n      // every result corresponds to a `TestElement`. Otherwise we need to verify which result was\n      // found by which selector so it can be matched to the appropriate instance.\n      const skipSelectorCheck = elementQueries.length === 0 && harnessTypes.size === 1 || harnessQueries.length === 0;\n      const perElementMatches = yield parallel(() => rawElements.map( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (rawElement) {\n          const testElement = _this21.createTestElement(rawElement);\n          const allResultsForElement = yield parallel(\n          // For each query, get `null` if it doesn't match, or a `TestElement` or\n          // `ComponentHarness` as appropriate if it does match. This gives us everything that\n          // matches the current raw element, but it may contain duplicate entries (e.g.\n          // multiple `TestElement` or multiple `ComponentHarness` of the same type).\n          () => allQueries.map(query => _this21._getQueryResultForElement(query, rawElement, testElement, skipSelectorCheck)));\n          return _removeDuplicateQueryResults(allResultsForElement);\n        });\n        return function (_x6) {\n          return _ref3.apply(this, arguments);\n        };\n      }()));\n      return [].concat(...perElementMatches);\n    })();\n  }\n  /**\n   * Check whether the given query matches the given element, if it does return the matched\n   * `TestElement` or `ComponentHarness`, if it does not, return null. In cases where the caller\n   * knows for sure that the query matches the element's selector, `skipSelectorCheck` can be used\n   * to skip verification and optimize performance.\n   */\n  _getQueryResultForElement(query, rawElement, testElement, skipSelectorCheck = false) {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      if (typeof query === 'string') {\n        return skipSelectorCheck || (yield testElement.matchesSelector(query)) ? testElement : null;\n      }\n      if (skipSelectorCheck || (yield testElement.matchesSelector(query.getSelector()))) {\n        const harness = _this22.createComponentHarness(query.harnessType, rawElement);\n        return (yield query.evaluate(harness)) ? harness : null;\n      }\n      return null;\n    })();\n  }\n}\n/**\n * Parses a list of queries in the format accepted by the `locatorFor*` methods into an easier to\n * work with format.\n */\nfunction _parseQueries(queries) {\n  const allQueries = [];\n  const harnessQueries = [];\n  const elementQueries = [];\n  const harnessTypes = new Set();\n  for (const query of queries) {\n    if (typeof query === 'string') {\n      allQueries.push(query);\n      elementQueries.push(query);\n    } else {\n      const predicate = query instanceof HarnessPredicate ? query : new HarnessPredicate(query, {});\n      allQueries.push(predicate);\n      harnessQueries.push(predicate);\n      harnessTypes.add(predicate.harnessType);\n    }\n  }\n  return {\n    allQueries,\n    harnessQueries,\n    elementQueries,\n    harnessTypes\n  };\n}\n/**\n * Removes duplicate query results for a particular element. (e.g. multiple `TestElement`\n * instances or multiple instances of the same `ComponentHarness` class.\n */\nfunction _removeDuplicateQueryResults(_x7) {\n  return _removeDuplicateQueryResults2.apply(this, arguments);\n}\n/** Verifies that there is at least one result in an array. */\nfunction _removeDuplicateQueryResults2() {\n  _removeDuplicateQueryResults2 = _asyncToGenerator(function* (results) {\n    let testElementMatched = false;\n    let matchedHarnessTypes = new Set();\n    const dedupedMatches = [];\n    for (const result of results) {\n      if (!result) {\n        continue;\n      }\n      if (result instanceof ComponentHarness) {\n        if (!matchedHarnessTypes.has(result.constructor)) {\n          matchedHarnessTypes.add(result.constructor);\n          dedupedMatches.push(result);\n        }\n      } else if (!testElementMatched) {\n        testElementMatched = true;\n        dedupedMatches.push(result);\n      }\n    }\n    return dedupedMatches;\n  });\n  return _removeDuplicateQueryResults2.apply(this, arguments);\n}\nfunction _assertResultFound(_x8, _x9) {\n  return _assertResultFound2.apply(this, arguments);\n}\n/** Gets a list of description strings from a list of queries. */\nfunction _assertResultFound2() {\n  _assertResultFound2 = _asyncToGenerator(function* (results, queryDescriptions) {\n    const result = (yield results)[0];\n    if (result == undefined) {\n      throw Error(`Failed to find element matching one of the following queries:\\n` + queryDescriptions.map(desc => `(${desc})`).join(',\\n'));\n    }\n    return result;\n  });\n  return _assertResultFound2.apply(this, arguments);\n}\nfunction _getDescriptionForLocatorForQueries(queries) {\n  return queries.map(query => typeof query === 'string' ? _getDescriptionForTestElementQuery(query) : _getDescriptionForComponentHarnessQuery(query));\n}\n/** Gets a description string for a `ComponentHarness` query. */\nfunction _getDescriptionForComponentHarnessQuery(query) {\n  const harnessPredicate = query instanceof HarnessPredicate ? query : new HarnessPredicate(query, {});\n  const {\n    name,\n    hostSelector\n  } = harnessPredicate.harnessType;\n  const description = `${name} with host element matching selector: \"${hostSelector}\"`;\n  const constraints = harnessPredicate.getDescription();\n  return description + (constraints ? ` satisfying the constraints: ${harnessPredicate.getDescription()}` : '');\n}\n/** Gets a description string for a `TestElement` query. */\nfunction _getDescriptionForTestElementQuery(selector) {\n  return `TestElement for element matching selector: \"${selector}\"`;\n}\n/** Gets a description string for a `HarnessLoader` query. */\nfunction _getDescriptionForHarnessLoaderQuery(selector) {\n  return `HarnessLoader for element matching selector: \"${selector}\"`;\n}\n\n/** An enum of non-text keys that can be used with the `sendKeys` method. */\n// NOTE: This is a separate enum from `@angular/cdk/keycodes` because we don't necessarily want to\n// support every possible keyCode. We also can't rely on Protractor's `Key` because we don't want a\n// dependency on any particular testing framework here. Instead we'll just maintain this supported\n// list of keys and let individual concrete `HarnessEnvironment` classes map them to whatever key\n// representation is used in its respective testing framework.\n// tslint:disable-next-line:prefer-const-enum Seems like this causes some issues with System.js\nvar TestKey;\n(function (TestKey) {\n  TestKey[TestKey[\"BACKSPACE\"] = 0] = \"BACKSPACE\";\n  TestKey[TestKey[\"TAB\"] = 1] = \"TAB\";\n  TestKey[TestKey[\"ENTER\"] = 2] = \"ENTER\";\n  TestKey[TestKey[\"SHIFT\"] = 3] = \"SHIFT\";\n  TestKey[TestKey[\"CONTROL\"] = 4] = \"CONTROL\";\n  TestKey[TestKey[\"ALT\"] = 5] = \"ALT\";\n  TestKey[TestKey[\"ESCAPE\"] = 6] = \"ESCAPE\";\n  TestKey[TestKey[\"PAGE_UP\"] = 7] = \"PAGE_UP\";\n  TestKey[TestKey[\"PAGE_DOWN\"] = 8] = \"PAGE_DOWN\";\n  TestKey[TestKey[\"END\"] = 9] = \"END\";\n  TestKey[TestKey[\"HOME\"] = 10] = \"HOME\";\n  TestKey[TestKey[\"LEFT_ARROW\"] = 11] = \"LEFT_ARROW\";\n  TestKey[TestKey[\"UP_ARROW\"] = 12] = \"UP_ARROW\";\n  TestKey[TestKey[\"RIGHT_ARROW\"] = 13] = \"RIGHT_ARROW\";\n  TestKey[TestKey[\"DOWN_ARROW\"] = 14] = \"DOWN_ARROW\";\n  TestKey[TestKey[\"INSERT\"] = 15] = \"INSERT\";\n  TestKey[TestKey[\"DELETE\"] = 16] = \"DELETE\";\n  TestKey[TestKey[\"F1\"] = 17] = \"F1\";\n  TestKey[TestKey[\"F2\"] = 18] = \"F2\";\n  TestKey[TestKey[\"F3\"] = 19] = \"F3\";\n  TestKey[TestKey[\"F4\"] = 20] = \"F4\";\n  TestKey[TestKey[\"F5\"] = 21] = \"F5\";\n  TestKey[TestKey[\"F6\"] = 22] = \"F6\";\n  TestKey[TestKey[\"F7\"] = 23] = \"F7\";\n  TestKey[TestKey[\"F8\"] = 24] = \"F8\";\n  TestKey[TestKey[\"F9\"] = 25] = \"F9\";\n  TestKey[TestKey[\"F10\"] = 26] = \"F10\";\n  TestKey[TestKey[\"F11\"] = 27] = \"F11\";\n  TestKey[TestKey[\"F12\"] = 28] = \"F12\";\n  TestKey[TestKey[\"META\"] = 29] = \"META\";\n  TestKey[TestKey[\"COMMA\"] = 30] = \"COMMA\";\n})(TestKey || (TestKey = {}));\n\n/**\n * Returns an error which reports that no keys have been specified.\n * @docs-private\n */\nfunction getNoKeysSpecifiedError() {\n  return Error('No keys have been specified.');\n}\n\n/**\n * Gets text of element excluding certain selectors within the element.\n * @param element Element to get text from,\n * @param excludeSelector Selector identifying which elements to exclude,\n */\nfunction _getTextWithExcludedElements(element, excludeSelector) {\n  const clone = element.cloneNode(true);\n  const exclusions = clone.querySelectorAll(excludeSelector);\n  for (let i = 0; i < exclusions.length; i++) {\n    exclusions[i].remove();\n  }\n  return (clone.textContent || '').trim();\n}\nexport { ComponentHarness, ContentContainerComponentHarness, HarnessEnvironment, HarnessPredicate, TestKey, _getTextWithExcludedElements, getNoKeysSpecifiedError, handleAutoChangeDetectionStatus, manualChangeDetection, parallel, stopHandlingAutoChangeDetectionStatus };","map":{"version":3,"names":["BehaviorSubject","autoChangeDetectionSubject","isDisabled","autoChangeDetectionSubscription","defaultAutoChangeDetectionHandler","status","onDetectChangesNow","handleAutoChangeDetectionStatus","handler","stopHandlingAutoChangeDetectionStatus","subscribe","unsubscribe","batchChangeDetection","_x","_x2","_batchChangeDetection","apply","arguments","_asyncToGenerator","fn","triggerBeforeAndAfter","getValue","Promise","resolve","next","manualChangeDetection","_x3","_manualChangeDetection","parallel","_x4","_parallel","values","all","ComponentHarness","constructor","locatorFactory","host","_this","rootElement","documentRootLocatorFactory","locatorFor","queries","locatorForOptional","locatorForAll","forceStabilize","_this2","waitForTasksOutsideAngular","_this3","ContentContainerComponentHarness","getChildLoader","selector","_this4","getRootHarnessLoader","getAllChildLoaders","_this5","getHarness","query","_this6","getHarnessOrNull","_this7","getAllHarnesses","_this8","hasHarness","_this9","_this10","rootHarnessLoader","HarnessPredicate","harnessType","options","_predicates","_descriptions","_addBaseOptions","stringMatches","value","pattern","test","add","description","predicate","push","addOption","name","option","undefined","_valueAsString","item","filter","harnesses","_this11","length","results","map","h","evaluate","_","i","harness","_this12","p","reduce","combined","current","getDescription","join","getSelector","_ancestor","hostSelector","trim","ancestors","ancestorPlaceholders","_splitAndEscapeSelector","selectors","selectorPlaceholders","result","forEach","escapedAncestor","ancestor","_restoreSelector","escapedSelector","_ref","matchesSelector","_x5","stringifiedValue","JSON","stringify","v","RegExp","toString","replace","placeholders","keep","replaceBy","split","part","index","HarnessEnvironment","_rootElement","createTestElement","rawRootElement","element","createEnvironment","getDocumentRoot","_assertResultFound","_getAllHarnessesAndTestElements","_getDescriptionForLocatorForQueries","_this13","_this14","harnessLoaderFor","_this15","getAllRawElements","_getDescriptionForHarnessLoaderQuery","harnessLoaderForOptional","_this16","elements","harnessLoaderForAll","_this17","_this18","_this19","_this20","e","createComponentHarness","_this21","Error","allQueries","harnessQueries","elementQueries","harnessTypes","_parseQueries","rawElements","skipSelectorCheck","size","perElementMatches","_ref3","rawElement","testElement","allResultsForElement","_getQueryResultForElement","_removeDuplicateQueryResults","_x6","concat","_this22","Set","_x7","_removeDuplicateQueryResults2","testElementMatched","matchedHarnessTypes","dedupedMatches","has","_x8","_x9","_assertResultFound2","queryDescriptions","desc","_getDescriptionForTestElementQuery","_getDescriptionForComponentHarnessQuery","harnessPredicate","constraints","TestKey","getNoKeysSpecifiedError","_getTextWithExcludedElements","excludeSelector","clone","cloneNode","exclusions","querySelectorAll","remove","textContent"],"sources":["C:/Users/USER/Desktop/Front-end/ProjectApp/node_modules/@angular/cdk/fesm2022/testing.mjs"],"sourcesContent":["import { BehaviorSubject } from 'rxjs';\n\n/** Subject used to dispatch and listen for changes to the auto change detection status . */\nconst autoChangeDetectionSubject = new BehaviorSubject({\n    isDisabled: false,\n});\n/** The current subscription to `autoChangeDetectionSubject`. */\nlet autoChangeDetectionSubscription;\n/**\n * The default handler for auto change detection status changes. This handler will be used if the\n * specific environment does not install its own.\n * @param status The new auto change detection status.\n */\nfunction defaultAutoChangeDetectionHandler(status) {\n    status.onDetectChangesNow?.();\n}\n/**\n * Allows a test `HarnessEnvironment` to install its own handler for auto change detection status\n * changes.\n * @param handler The handler for the auto change detection status.\n */\nfunction handleAutoChangeDetectionStatus(handler) {\n    stopHandlingAutoChangeDetectionStatus();\n    autoChangeDetectionSubscription = autoChangeDetectionSubject.subscribe(handler);\n}\n/** Allows a `HarnessEnvironment` to stop handling auto change detection status changes. */\nfunction stopHandlingAutoChangeDetectionStatus() {\n    autoChangeDetectionSubscription?.unsubscribe();\n    autoChangeDetectionSubscription = null;\n}\n/**\n * Batches together triggering of change detection over the duration of the given function.\n * @param fn The function to call with batched change detection.\n * @param triggerBeforeAndAfter Optionally trigger change detection once before and after the batch\n *   operation. If false, change detection will not be triggered.\n * @return The result of the given function.\n */\nasync function batchChangeDetection(fn, triggerBeforeAndAfter) {\n    // If change detection batching is already in progress, just run the function.\n    if (autoChangeDetectionSubject.getValue().isDisabled) {\n        return await fn();\n    }\n    // If nothing is handling change detection batching, install the default handler.\n    if (!autoChangeDetectionSubscription) {\n        handleAutoChangeDetectionStatus(defaultAutoChangeDetectionHandler);\n    }\n    if (triggerBeforeAndAfter) {\n        await new Promise(resolve => autoChangeDetectionSubject.next({\n            isDisabled: true,\n            onDetectChangesNow: resolve,\n        }));\n        // The function passed in may throw (e.g. if the user wants to make an expectation of an error\n        // being thrown. If this happens, we need to make sure we still re-enable change detection, so\n        // we wrap it in a `finally` block.\n        try {\n            return await fn();\n        }\n        finally {\n            await new Promise(resolve => autoChangeDetectionSubject.next({\n                isDisabled: false,\n                onDetectChangesNow: resolve,\n            }));\n        }\n    }\n    else {\n        autoChangeDetectionSubject.next({ isDisabled: true });\n        // The function passed in may throw (e.g. if the user wants to make an expectation of an error\n        // being thrown. If this happens, we need to make sure we still re-enable change detection, so\n        // we wrap it in a `finally` block.\n        try {\n            return await fn();\n        }\n        finally {\n            autoChangeDetectionSubject.next({ isDisabled: false });\n        }\n    }\n}\n/**\n * Disables the harness system's auto change detection for the duration of the given function.\n * @param fn The function to disable auto change detection for.\n * @return The result of the given function.\n */\nasync function manualChangeDetection(fn) {\n    return batchChangeDetection(fn, false);\n}\n/**\n * Resolves the given list of async values in parallel (i.e. via Promise.all) while batching change\n * detection over the entire operation such that change detection occurs exactly once before\n * resolving the values and once after.\n * @param values A getter for the async values to resolve in parallel with batched change detection.\n * @return The resolved values.\n */\nasync function parallel(values) {\n    return batchChangeDetection(() => Promise.all(values()), true);\n}\n\n/**\n * Base class for component harnesses that all component harness authors should extend. This base\n * component harness provides the basic ability to locate element and sub-component harness. It\n * should be inherited when defining user's own harness.\n */\nclass ComponentHarness {\n    constructor(locatorFactory) {\n        this.locatorFactory = locatorFactory;\n    }\n    /** Gets a `Promise` for the `TestElement` representing the host element of the component. */\n    async host() {\n        return this.locatorFactory.rootElement;\n    }\n    /**\n     * Gets a `LocatorFactory` for the document root element. This factory can be used to create\n     * locators for elements that a component creates outside of its own root element. (e.g. by\n     * appending to document.body).\n     */\n    documentRootLocatorFactory() {\n        return this.locatorFactory.documentRootLocatorFactory();\n    }\n    /**\n     * Creates an asynchronous locator function that can be used to find a `ComponentHarness` instance\n     * or element under the host element of this `ComponentHarness`.\n     * @param queries A list of queries specifying which harnesses and elements to search for:\n     *   - A `string` searches for elements matching the CSS selector specified by the string.\n     *   - A `ComponentHarness` constructor searches for `ComponentHarness` instances matching the\n     *     given class.\n     *   - A `HarnessPredicate` searches for `ComponentHarness` instances matching the given\n     *     predicate.\n     * @return An asynchronous locator function that searches for and returns a `Promise` for the\n     *   first element or harness matching the given search criteria. Matches are ordered first by\n     *   order in the DOM, and second by order in the queries list. If no matches are found, the\n     *   `Promise` rejects. The type that the `Promise` resolves to is a union of all result types for\n     *   each query.\n     *\n     * e.g. Given the following DOM: `<div id=\"d1\" /><div id=\"d2\" />`, and assuming\n     * `DivHarness.hostSelector === 'div'`:\n     * - `await ch.locatorFor(DivHarness, 'div')()` gets a `DivHarness` instance for `#d1`\n     * - `await ch.locatorFor('div', DivHarness)()` gets a `TestElement` instance for `#d1`\n     * - `await ch.locatorFor('span')()` throws because the `Promise` rejects.\n     */\n    locatorFor(...queries) {\n        return this.locatorFactory.locatorFor(...queries);\n    }\n    /**\n     * Creates an asynchronous locator function that can be used to find a `ComponentHarness` instance\n     * or element under the host element of this `ComponentHarness`.\n     * @param queries A list of queries specifying which harnesses and elements to search for:\n     *   - A `string` searches for elements matching the CSS selector specified by the string.\n     *   - A `ComponentHarness` constructor searches for `ComponentHarness` instances matching the\n     *     given class.\n     *   - A `HarnessPredicate` searches for `ComponentHarness` instances matching the given\n     *     predicate.\n     * @return An asynchronous locator function that searches for and returns a `Promise` for the\n     *   first element or harness matching the given search criteria. Matches are ordered first by\n     *   order in the DOM, and second by order in the queries list. If no matches are found, the\n     *   `Promise` is resolved with `null`. The type that the `Promise` resolves to is a union of all\n     *   result types for each query or null.\n     *\n     * e.g. Given the following DOM: `<div id=\"d1\" /><div id=\"d2\" />`, and assuming\n     * `DivHarness.hostSelector === 'div'`:\n     * - `await ch.locatorForOptional(DivHarness, 'div')()` gets a `DivHarness` instance for `#d1`\n     * - `await ch.locatorForOptional('div', DivHarness)()` gets a `TestElement` instance for `#d1`\n     * - `await ch.locatorForOptional('span')()` gets `null`.\n     */\n    locatorForOptional(...queries) {\n        return this.locatorFactory.locatorForOptional(...queries);\n    }\n    /**\n     * Creates an asynchronous locator function that can be used to find `ComponentHarness` instances\n     * or elements under the host element of this `ComponentHarness`.\n     * @param queries A list of queries specifying which harnesses and elements to search for:\n     *   - A `string` searches for elements matching the CSS selector specified by the string.\n     *   - A `ComponentHarness` constructor searches for `ComponentHarness` instances matching the\n     *     given class.\n     *   - A `HarnessPredicate` searches for `ComponentHarness` instances matching the given\n     *     predicate.\n     * @return An asynchronous locator function that searches for and returns a `Promise` for all\n     *   elements and harnesses matching the given search criteria. Matches are ordered first by\n     *   order in the DOM, and second by order in the queries list. If an element matches more than\n     *   one `ComponentHarness` class, the locator gets an instance of each for the same element. If\n     *   an element matches multiple `string` selectors, only one `TestElement` instance is returned\n     *   for that element. The type that the `Promise` resolves to is an array where each element is\n     *   the union of all result types for each query.\n     *\n     * e.g. Given the following DOM: `<div id=\"d1\" /><div id=\"d2\" />`, and assuming\n     * `DivHarness.hostSelector === 'div'` and `IdIsD1Harness.hostSelector === '#d1'`:\n     * - `await ch.locatorForAll(DivHarness, 'div')()` gets `[\n     *     DivHarness, // for #d1\n     *     TestElement, // for #d1\n     *     DivHarness, // for #d2\n     *     TestElement // for #d2\n     *   ]`\n     * - `await ch.locatorForAll('div', '#d1')()` gets `[\n     *     TestElement, // for #d1\n     *     TestElement // for #d2\n     *   ]`\n     * - `await ch.locatorForAll(DivHarness, IdIsD1Harness)()` gets `[\n     *     DivHarness, // for #d1\n     *     IdIsD1Harness, // for #d1\n     *     DivHarness // for #d2\n     *   ]`\n     * - `await ch.locatorForAll('span')()` gets `[]`.\n     */\n    locatorForAll(...queries) {\n        return this.locatorFactory.locatorForAll(...queries);\n    }\n    /**\n     * Flushes change detection and async tasks in the Angular zone.\n     * In most cases it should not be necessary to call this manually. However, there may be some edge\n     * cases where it is needed to fully flush animation events.\n     */\n    async forceStabilize() {\n        return this.locatorFactory.forceStabilize();\n    }\n    /**\n     * Waits for all scheduled or running async tasks to complete. This allows harness\n     * authors to wait for async tasks outside of the Angular zone.\n     */\n    async waitForTasksOutsideAngular() {\n        return this.locatorFactory.waitForTasksOutsideAngular();\n    }\n}\n/**\n * Base class for component harnesses that authors should extend if they anticipate that consumers\n * of the harness may want to access other harnesses within the `<ng-content>` of the component.\n */\nclass ContentContainerComponentHarness extends ComponentHarness {\n    async getChildLoader(selector) {\n        return (await this.getRootHarnessLoader()).getChildLoader(selector);\n    }\n    async getAllChildLoaders(selector) {\n        return (await this.getRootHarnessLoader()).getAllChildLoaders(selector);\n    }\n    async getHarness(query) {\n        return (await this.getRootHarnessLoader()).getHarness(query);\n    }\n    async getHarnessOrNull(query) {\n        return (await this.getRootHarnessLoader()).getHarnessOrNull(query);\n    }\n    async getAllHarnesses(query) {\n        return (await this.getRootHarnessLoader()).getAllHarnesses(query);\n    }\n    async hasHarness(query) {\n        return (await this.getRootHarnessLoader()).hasHarness(query);\n    }\n    /**\n     * Gets the root harness loader from which to start\n     * searching for content contained by this harness.\n     */\n    async getRootHarnessLoader() {\n        return this.locatorFactory.rootHarnessLoader();\n    }\n}\n/**\n * A class used to associate a ComponentHarness class with predicates functions that can be used to\n * filter instances of the class.\n */\nclass HarnessPredicate {\n    constructor(harnessType, options) {\n        this.harnessType = harnessType;\n        this._predicates = [];\n        this._descriptions = [];\n        this._addBaseOptions(options);\n    }\n    /**\n     * Checks if the specified nullable string value matches the given pattern.\n     * @param value The nullable string value to check, or a Promise resolving to the\n     *   nullable string value.\n     * @param pattern The pattern the value is expected to match. If `pattern` is a string,\n     *   `value` is expected to match exactly. If `pattern` is a regex, a partial match is\n     *   allowed. If `pattern` is `null`, the value is expected to be `null`.\n     * @return Whether the value matches the pattern.\n     */\n    static async stringMatches(value, pattern) {\n        value = await value;\n        if (pattern === null) {\n            return value === null;\n        }\n        else if (value === null) {\n            return false;\n        }\n        return typeof pattern === 'string' ? value === pattern : pattern.test(value);\n    }\n    /**\n     * Adds a predicate function to be run against candidate harnesses.\n     * @param description A description of this predicate that may be used in error messages.\n     * @param predicate An async predicate function.\n     * @return this (for method chaining).\n     */\n    add(description, predicate) {\n        this._descriptions.push(description);\n        this._predicates.push(predicate);\n        return this;\n    }\n    /**\n     * Adds a predicate function that depends on an option value to be run against candidate\n     * harnesses. If the option value is undefined, the predicate will be ignored.\n     * @param name The name of the option (may be used in error messages).\n     * @param option The option value.\n     * @param predicate The predicate function to run if the option value is not undefined.\n     * @return this (for method chaining).\n     */\n    addOption(name, option, predicate) {\n        if (option !== undefined) {\n            this.add(`${name} = ${_valueAsString(option)}`, item => predicate(item, option));\n        }\n        return this;\n    }\n    /**\n     * Filters a list of harnesses on this predicate.\n     * @param harnesses The list of harnesses to filter.\n     * @return A list of harnesses that satisfy this predicate.\n     */\n    async filter(harnesses) {\n        if (harnesses.length === 0) {\n            return [];\n        }\n        const results = await parallel(() => harnesses.map(h => this.evaluate(h)));\n        return harnesses.filter((_, i) => results[i]);\n    }\n    /**\n     * Evaluates whether the given harness satisfies this predicate.\n     * @param harness The harness to check\n     * @return A promise that resolves to true if the harness satisfies this predicate,\n     *   and resolves to false otherwise.\n     */\n    async evaluate(harness) {\n        const results = await parallel(() => this._predicates.map(p => p(harness)));\n        return results.reduce((combined, current) => combined && current, true);\n    }\n    /** Gets a description of this predicate for use in error messages. */\n    getDescription() {\n        return this._descriptions.join(', ');\n    }\n    /** Gets the selector used to find candidate elements. */\n    getSelector() {\n        // We don't have to go through the extra trouble if there are no ancestors.\n        if (!this._ancestor) {\n            return (this.harnessType.hostSelector || '').trim();\n        }\n        const [ancestors, ancestorPlaceholders] = _splitAndEscapeSelector(this._ancestor);\n        const [selectors, selectorPlaceholders] = _splitAndEscapeSelector(this.harnessType.hostSelector || '');\n        const result = [];\n        // We have to add the ancestor to each part of the host compound selector, otherwise we can get\n        // incorrect results. E.g. `.ancestor .a, .ancestor .b` vs `.ancestor .a, .b`.\n        ancestors.forEach(escapedAncestor => {\n            const ancestor = _restoreSelector(escapedAncestor, ancestorPlaceholders);\n            return selectors.forEach(escapedSelector => result.push(`${ancestor} ${_restoreSelector(escapedSelector, selectorPlaceholders)}`));\n        });\n        return result.join(', ');\n    }\n    /** Adds base options common to all harness types. */\n    _addBaseOptions(options) {\n        this._ancestor = options.ancestor || '';\n        if (this._ancestor) {\n            this._descriptions.push(`has ancestor matching selector \"${this._ancestor}\"`);\n        }\n        const selector = options.selector;\n        if (selector !== undefined) {\n            this.add(`host matches selector \"${selector}\"`, async (item) => {\n                return (await item.host()).matchesSelector(selector);\n            });\n        }\n    }\n}\n/** Represent a value as a string for the purpose of logging. */\nfunction _valueAsString(value) {\n    if (value === undefined) {\n        return 'undefined';\n    }\n    try {\n        // `JSON.stringify` doesn't handle RegExp properly, so we need a custom replacer.\n        // Use a character that is unlikely to appear in real strings to denote the start and end of\n        // the regex. This allows us to strip out the extra quotes around the value added by\n        // `JSON.stringify`. Also do custom escaping on `\"` characters to prevent `JSON.stringify`\n        // from escaping them as if they were part of a string.\n        const stringifiedValue = JSON.stringify(value, (_, v) => v instanceof RegExp\n            ? `◬MAT_RE_ESCAPE◬${v.toString().replace(/\"/g, '◬MAT_RE_ESCAPE◬')}◬MAT_RE_ESCAPE◬`\n            : v);\n        // Strip out the extra quotes around regexes and put back the manually escaped `\"` characters.\n        return stringifiedValue\n            .replace(/\"◬MAT_RE_ESCAPE◬|◬MAT_RE_ESCAPE◬\"/g, '')\n            .replace(/◬MAT_RE_ESCAPE◬/g, '\"');\n    }\n    catch {\n        // `JSON.stringify` will throw if the object is cyclical,\n        // in this case the best we can do is report the value as `{...}`.\n        return '{...}';\n    }\n}\n/**\n * Splits up a compound selector into its parts and escapes any quoted content. The quoted content\n * has to be escaped, because it can contain commas which will throw throw us off when trying to\n * split it.\n * @param selector Selector to be split.\n * @returns The escaped string where any quoted content is replaced with a placeholder. E.g.\n * `[foo=\"bar\"]` turns into `[foo=__cdkPlaceholder-0__]`. Use `_restoreSelector` to restore\n * the placeholders.\n */\nfunction _splitAndEscapeSelector(selector) {\n    const placeholders = [];\n    // Note that the regex doesn't account for nested quotes so something like `\"ab'cd'e\"` will be\n    // considered as two blocks. It's a bit of an edge case, but if we find that it's a problem,\n    // we can make it a bit smarter using a loop. Use this for now since it's more readable and\n    // compact. More complete implementation:\n    // https://github.com/angular/angular/blob/bd34bc9e89f18a/packages/compiler/src/shadow_css.ts#L655\n    const result = selector.replace(/([\"'][^[\"']*[\"'])/g, (_, keep) => {\n        const replaceBy = `__cdkPlaceholder-${placeholders.length}__`;\n        placeholders.push(keep);\n        return replaceBy;\n    });\n    return [result.split(',').map(part => part.trim()), placeholders];\n}\n/** Restores a selector whose content was escaped in `_splitAndEscapeSelector`. */\nfunction _restoreSelector(selector, placeholders) {\n    return selector.replace(/__cdkPlaceholder-(\\d+)__/g, (_, index) => placeholders[+index]);\n}\n\n/**\n * Base harness environment class that can be extended to allow `ComponentHarness`es to be used in\n * different test environments (e.g. testbed, protractor, etc.). This class implements the\n * functionality of both a `HarnessLoader` and `LocatorFactory`. This class is generic on the raw\n * element type, `E`, used by the particular test environment.\n */\nclass HarnessEnvironment {\n    // Implemented as part of the `LocatorFactory` interface.\n    get rootElement() {\n        this._rootElement = this._rootElement || this.createTestElement(this.rawRootElement);\n        return this._rootElement;\n    }\n    set rootElement(element) {\n        this._rootElement = element;\n    }\n    constructor(rawRootElement) {\n        this.rawRootElement = rawRootElement;\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    documentRootLocatorFactory() {\n        return this.createEnvironment(this.getDocumentRoot());\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    locatorFor(...queries) {\n        return () => _assertResultFound(this._getAllHarnessesAndTestElements(queries), _getDescriptionForLocatorForQueries(queries));\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    locatorForOptional(...queries) {\n        return async () => (await this._getAllHarnessesAndTestElements(queries))[0] || null;\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    locatorForAll(...queries) {\n        return () => this._getAllHarnessesAndTestElements(queries);\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    async rootHarnessLoader() {\n        return this;\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    async harnessLoaderFor(selector) {\n        return this.createEnvironment(await _assertResultFound(this.getAllRawElements(selector), [\n            _getDescriptionForHarnessLoaderQuery(selector),\n        ]));\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    async harnessLoaderForOptional(selector) {\n        const elements = await this.getAllRawElements(selector);\n        return elements[0] ? this.createEnvironment(elements[0]) : null;\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    async harnessLoaderForAll(selector) {\n        const elements = await this.getAllRawElements(selector);\n        return elements.map(element => this.createEnvironment(element));\n    }\n    // Implemented as part of the `HarnessLoader` interface.\n    getHarness(query) {\n        return this.locatorFor(query)();\n    }\n    // Implemented as part of the `HarnessLoader` interface.\n    getHarnessOrNull(query) {\n        return this.locatorForOptional(query)();\n    }\n    // Implemented as part of the `HarnessLoader` interface.\n    getAllHarnesses(query) {\n        return this.locatorForAll(query)();\n    }\n    // Implemented as part of the `HarnessLoader` interface.\n    async hasHarness(query) {\n        return (await this.locatorForOptional(query)()) !== null;\n    }\n    // Implemented as part of the `HarnessLoader` interface.\n    async getChildLoader(selector) {\n        return this.createEnvironment(await _assertResultFound(this.getAllRawElements(selector), [\n            _getDescriptionForHarnessLoaderQuery(selector),\n        ]));\n    }\n    // Implemented as part of the `HarnessLoader` interface.\n    async getAllChildLoaders(selector) {\n        return (await this.getAllRawElements(selector)).map(e => this.createEnvironment(e));\n    }\n    /** Creates a `ComponentHarness` for the given harness type with the given raw host element. */\n    createComponentHarness(harnessType, element) {\n        return new harnessType(this.createEnvironment(element));\n    }\n    /**\n     * Matches the given raw elements with the given list of element and harness queries to produce a\n     * list of matched harnesses and test elements.\n     */\n    async _getAllHarnessesAndTestElements(queries) {\n        if (!queries.length) {\n            throw Error('CDK Component harness query must contain at least one element.');\n        }\n        const { allQueries, harnessQueries, elementQueries, harnessTypes } = _parseQueries(queries);\n        // Combine all of the queries into one large comma-delimited selector and use it to get all raw\n        // elements matching any of the individual queries.\n        const rawElements = await this.getAllRawElements([...elementQueries, ...harnessQueries.map(predicate => predicate.getSelector())].join(','));\n        // If every query is searching for the same harness subclass, we know every result corresponds\n        // to an instance of that subclass. Likewise, if every query is for a `TestElement`, we know\n        // every result corresponds to a `TestElement`. Otherwise we need to verify which result was\n        // found by which selector so it can be matched to the appropriate instance.\n        const skipSelectorCheck = (elementQueries.length === 0 && harnessTypes.size === 1) || harnessQueries.length === 0;\n        const perElementMatches = await parallel(() => rawElements.map(async (rawElement) => {\n            const testElement = this.createTestElement(rawElement);\n            const allResultsForElement = await parallel(\n            // For each query, get `null` if it doesn't match, or a `TestElement` or\n            // `ComponentHarness` as appropriate if it does match. This gives us everything that\n            // matches the current raw element, but it may contain duplicate entries (e.g.\n            // multiple `TestElement` or multiple `ComponentHarness` of the same type).\n            () => allQueries.map(query => this._getQueryResultForElement(query, rawElement, testElement, skipSelectorCheck)));\n            return _removeDuplicateQueryResults(allResultsForElement);\n        }));\n        return [].concat(...perElementMatches);\n    }\n    /**\n     * Check whether the given query matches the given element, if it does return the matched\n     * `TestElement` or `ComponentHarness`, if it does not, return null. In cases where the caller\n     * knows for sure that the query matches the element's selector, `skipSelectorCheck` can be used\n     * to skip verification and optimize performance.\n     */\n    async _getQueryResultForElement(query, rawElement, testElement, skipSelectorCheck = false) {\n        if (typeof query === 'string') {\n            return skipSelectorCheck || (await testElement.matchesSelector(query)) ? testElement : null;\n        }\n        if (skipSelectorCheck || (await testElement.matchesSelector(query.getSelector()))) {\n            const harness = this.createComponentHarness(query.harnessType, rawElement);\n            return (await query.evaluate(harness)) ? harness : null;\n        }\n        return null;\n    }\n}\n/**\n * Parses a list of queries in the format accepted by the `locatorFor*` methods into an easier to\n * work with format.\n */\nfunction _parseQueries(queries) {\n    const allQueries = [];\n    const harnessQueries = [];\n    const elementQueries = [];\n    const harnessTypes = new Set();\n    for (const query of queries) {\n        if (typeof query === 'string') {\n            allQueries.push(query);\n            elementQueries.push(query);\n        }\n        else {\n            const predicate = query instanceof HarnessPredicate ? query : new HarnessPredicate(query, {});\n            allQueries.push(predicate);\n            harnessQueries.push(predicate);\n            harnessTypes.add(predicate.harnessType);\n        }\n    }\n    return { allQueries, harnessQueries, elementQueries, harnessTypes };\n}\n/**\n * Removes duplicate query results for a particular element. (e.g. multiple `TestElement`\n * instances or multiple instances of the same `ComponentHarness` class.\n */\nasync function _removeDuplicateQueryResults(results) {\n    let testElementMatched = false;\n    let matchedHarnessTypes = new Set();\n    const dedupedMatches = [];\n    for (const result of results) {\n        if (!result) {\n            continue;\n        }\n        if (result instanceof ComponentHarness) {\n            if (!matchedHarnessTypes.has(result.constructor)) {\n                matchedHarnessTypes.add(result.constructor);\n                dedupedMatches.push(result);\n            }\n        }\n        else if (!testElementMatched) {\n            testElementMatched = true;\n            dedupedMatches.push(result);\n        }\n    }\n    return dedupedMatches;\n}\n/** Verifies that there is at least one result in an array. */\nasync function _assertResultFound(results, queryDescriptions) {\n    const result = (await results)[0];\n    if (result == undefined) {\n        throw Error(`Failed to find element matching one of the following queries:\\n` +\n            queryDescriptions.map(desc => `(${desc})`).join(',\\n'));\n    }\n    return result;\n}\n/** Gets a list of description strings from a list of queries. */\nfunction _getDescriptionForLocatorForQueries(queries) {\n    return queries.map(query => typeof query === 'string'\n        ? _getDescriptionForTestElementQuery(query)\n        : _getDescriptionForComponentHarnessQuery(query));\n}\n/** Gets a description string for a `ComponentHarness` query. */\nfunction _getDescriptionForComponentHarnessQuery(query) {\n    const harnessPredicate = query instanceof HarnessPredicate ? query : new HarnessPredicate(query, {});\n    const { name, hostSelector } = harnessPredicate.harnessType;\n    const description = `${name} with host element matching selector: \"${hostSelector}\"`;\n    const constraints = harnessPredicate.getDescription();\n    return (description +\n        (constraints ? ` satisfying the constraints: ${harnessPredicate.getDescription()}` : ''));\n}\n/** Gets a description string for a `TestElement` query. */\nfunction _getDescriptionForTestElementQuery(selector) {\n    return `TestElement for element matching selector: \"${selector}\"`;\n}\n/** Gets a description string for a `HarnessLoader` query. */\nfunction _getDescriptionForHarnessLoaderQuery(selector) {\n    return `HarnessLoader for element matching selector: \"${selector}\"`;\n}\n\n/** An enum of non-text keys that can be used with the `sendKeys` method. */\n// NOTE: This is a separate enum from `@angular/cdk/keycodes` because we don't necessarily want to\n// support every possible keyCode. We also can't rely on Protractor's `Key` because we don't want a\n// dependency on any particular testing framework here. Instead we'll just maintain this supported\n// list of keys and let individual concrete `HarnessEnvironment` classes map them to whatever key\n// representation is used in its respective testing framework.\n// tslint:disable-next-line:prefer-const-enum Seems like this causes some issues with System.js\nvar TestKey;\n(function (TestKey) {\n    TestKey[TestKey[\"BACKSPACE\"] = 0] = \"BACKSPACE\";\n    TestKey[TestKey[\"TAB\"] = 1] = \"TAB\";\n    TestKey[TestKey[\"ENTER\"] = 2] = \"ENTER\";\n    TestKey[TestKey[\"SHIFT\"] = 3] = \"SHIFT\";\n    TestKey[TestKey[\"CONTROL\"] = 4] = \"CONTROL\";\n    TestKey[TestKey[\"ALT\"] = 5] = \"ALT\";\n    TestKey[TestKey[\"ESCAPE\"] = 6] = \"ESCAPE\";\n    TestKey[TestKey[\"PAGE_UP\"] = 7] = \"PAGE_UP\";\n    TestKey[TestKey[\"PAGE_DOWN\"] = 8] = \"PAGE_DOWN\";\n    TestKey[TestKey[\"END\"] = 9] = \"END\";\n    TestKey[TestKey[\"HOME\"] = 10] = \"HOME\";\n    TestKey[TestKey[\"LEFT_ARROW\"] = 11] = \"LEFT_ARROW\";\n    TestKey[TestKey[\"UP_ARROW\"] = 12] = \"UP_ARROW\";\n    TestKey[TestKey[\"RIGHT_ARROW\"] = 13] = \"RIGHT_ARROW\";\n    TestKey[TestKey[\"DOWN_ARROW\"] = 14] = \"DOWN_ARROW\";\n    TestKey[TestKey[\"INSERT\"] = 15] = \"INSERT\";\n    TestKey[TestKey[\"DELETE\"] = 16] = \"DELETE\";\n    TestKey[TestKey[\"F1\"] = 17] = \"F1\";\n    TestKey[TestKey[\"F2\"] = 18] = \"F2\";\n    TestKey[TestKey[\"F3\"] = 19] = \"F3\";\n    TestKey[TestKey[\"F4\"] = 20] = \"F4\";\n    TestKey[TestKey[\"F5\"] = 21] = \"F5\";\n    TestKey[TestKey[\"F6\"] = 22] = \"F6\";\n    TestKey[TestKey[\"F7\"] = 23] = \"F7\";\n    TestKey[TestKey[\"F8\"] = 24] = \"F8\";\n    TestKey[TestKey[\"F9\"] = 25] = \"F9\";\n    TestKey[TestKey[\"F10\"] = 26] = \"F10\";\n    TestKey[TestKey[\"F11\"] = 27] = \"F11\";\n    TestKey[TestKey[\"F12\"] = 28] = \"F12\";\n    TestKey[TestKey[\"META\"] = 29] = \"META\";\n    TestKey[TestKey[\"COMMA\"] = 30] = \"COMMA\";\n})(TestKey || (TestKey = {}));\n\n/**\n * Returns an error which reports that no keys have been specified.\n * @docs-private\n */\nfunction getNoKeysSpecifiedError() {\n    return Error('No keys have been specified.');\n}\n\n/**\n * Gets text of element excluding certain selectors within the element.\n * @param element Element to get text from,\n * @param excludeSelector Selector identifying which elements to exclude,\n */\nfunction _getTextWithExcludedElements(element, excludeSelector) {\n    const clone = element.cloneNode(true);\n    const exclusions = clone.querySelectorAll(excludeSelector);\n    for (let i = 0; i < exclusions.length; i++) {\n        exclusions[i].remove();\n    }\n    return (clone.textContent || '').trim();\n}\n\nexport { ComponentHarness, ContentContainerComponentHarness, HarnessEnvironment, HarnessPredicate, TestKey, _getTextWithExcludedElements, getNoKeysSpecifiedError, handleAutoChangeDetectionStatus, manualChangeDetection, parallel, stopHandlingAutoChangeDetectionStatus };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}